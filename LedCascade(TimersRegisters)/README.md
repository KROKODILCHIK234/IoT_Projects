# Проект LedCascade: Асинхронное управление светодиодами на ATmega328P с использованием аппаратных прерываний

## 1. Введение

### 1.1. Контекст и цель проекта

Данный проект демонстрирует создание эффективной многозадачной системы управления периферией на примере пяти светодиодов, работающих с независимыми периодами мигания. Основная цель — реализовать неблокирующую логику управления, используя низкоуровневые возможности микроконтроллера ATmega328P: прямое манипулирование регистрами и аппаратные прерывания таймера. Такой подход является фундаментальным для разработки встраиваемых систем реального времени.

### 1.2. Обоснование выбранного подхода

Применение стандартных функций, таких как `delay()`, приводит к полной остановке (блокировке) микроконтроллера, что делает невозможным параллельное выполнение других задач. Использование высокоуровневых функций Arduino (`digitalWrite()`, `millis()`) вносит дополнительные накладные расходы и снижает детерминизм системы.

Выбранное решение основано на **аппаратных прерываниях от таймера**. Этот механизм позволяет выполнять основной код (`loop()`) и обработку событий асинхронно, обеспечивая максимальную отзывчивость и производительность системы. Управление выводами осуществляется напрямую через регистры `DDRB` и `PORTB` для минимизации задержек и полного контроля над аппаратной частью.

### 1.3. Архитектура решения

В основе архитектуры лежит модульный подход. Вместо глобального счётчика и ресурсоёмкой операции деления по модулю (`%`) для каждого светодиода создаётся отдельная управляющая структура (`LedController`). Эта структура инкапсулирует все необходимые параметры: номер пина, период мигания и индивидуальный счётчик обратного отсчёта.

Единый аппаратный таймер генерирует прерывания с фиксированным интервалом («тик»). Внутри обработчика прерывания (ISR) происходит итерация по массиву управляющих структур, декремент каждого счётчика и, при его обнулении, инверсия состояния соответствующего светодиода. Такая архитектура более масштабируема и эффективна.

## 2. Аппаратная конфигурация

### 2.1. Список компонентов

*   Плата Arduino UNO (на базе ATmega328P).
*   5 светодиодов.
*   5 токоограничивающих резисторов (номинал 220 Ом).
*   Макетная плата и соединительные провода.

### 2.2. Схема подключения

Светодиоды подключены к пинам порта `B` для удобства манипуляции через регистр `PORTB`.

| Компонент | Пин Arduino | Регистр и бит |
| :-------- | :---------: | :-----------: |
| Светодиод 1 |      8      |      PB0      |
| Светодиод 2 |      9      |      PB1      |
| Светодиод 3 |      10     |      PB2      |
| Светодиод 4 |      12     |      PB4      |
| Светодиод 5 |      13     |      PB5      |

## 3. Программная реализация

### 3.1. Структура данных (`LedController`)

Для организации управления была введена структура `LedController`, которая объединяет все параметры одного светодиода:

*   `pin`: номер бита в порте B, к которому подключен светодиод.
*   `reload_value`: константа, определяющая период мигания в "тиках" таймера.
*   `countdown`: переменная-счётчик, которая декрементируется при каждом тике таймера.

Такой подход позволяет легко добавлять новые светодиоды или изменять их параметры, не затрагивая основную логику.

### 3.2. Конфигурация Таймера1

Используется 16-битный **Таймер1** в режиме **CTC** (Clear Timer on Compare), что обеспечивает точную периодичность прерываний.

*   **Тактовая частота МК (F_CPU):** 16 МГц.
*   **Предделитель (Prescaler):** 64. Частота работы таймера: `16,000,000 Гц / 64 = 250,000` Гц.
*   **Требуемый интервал прерывания (базовый тик):** 40 мс (частота 25 Гц).
*   **Расчёт значения для `OCR1A`:**
    `OCR1A = (Частота таймера / Частота прерываний) - 1 = (250,000 / 25) - 1 = 9999`.

При достижении счётчиком `TCNT1` значения 9999 генерируется прерывание `TIMER1_COMPA_vect`, и счётчик автоматически сбрасывается в ноль.

### 3.3. Логика обработчика прерываний (ISR)

Обработчик прерывания `ISR(TIMER1_COMPA_vect)` выполняется каждые 40 мс и реализует всю логику управления:
1.  Осуществляется проход по массиву структур `led_array`.
2.  Для каждого светодиода декрементируется его личный счётчик `countdown`.
3.  Если счётчик достигает нуля, выполняется два действия:
    *   Состояние соответствующего пина инвертируется с помощью побитовой операции `XOR` (`PORTB ^= ...`).
    *   Счётчик `countdown` сбрасывается в своё начальное значение `reload_value`.

Этот метод не содержит сложных вычислений, что делает ISR максимально быстрым и эффективным.

### 3.4. Исходный код

Финальный код, реализующий описанную архитектуру.

```cpp
#include <avr/io.h>
#include <avr/interrupt.h>

// Define a structure to manage each LED
struct LedController {
  const uint8_t pin;      // The pin the LED is connected to
  const int reload_value; // The value to which the counter resets (the period)
  int countdown;          // The current countdown value
};

// Create and initialize an array of LEDs
LedController led_array[] = {
  {PB0, 10, 10}, // Period 10 * 40 ms = 400 ms
  {PB1, 20, 20}, // Period 20 * 40 ms = 800 ms
  {PB2, 30, 30}, // Period 30 * 40 ms = 1200 ms
  {PB4, 40, 40}, // Period 40 * 40 ms = 1600 ms
  {PB5, 50, 50}  // Period 50 * 40 ms = 2000 ms
};

// Get the number of LEDs from the size of the array
const int number_of_leds = sizeof(led_array) / sizeof(led_array[0]);

// Helper function to configure GPIO pins
void configure_gpio() {
  uint8_t pin_mask = 0;
  for (int i = 0; i < number_of_leds; i++) {
    pin_mask |= (1 << led_array[i].pin);
  }
  DDRB |= pin_mask;  // Set all selected pins as outputs
  PORTB &= ~pin_mask; // Turn off all LEDs initially
}

// Helper function to configure the timer
void configure_timer_interrupts() {
  cli(); // Disable global interrupts during setup
  
  TCCR1A = 0;
  TCCR1B = 0;
  
  TCCR1B |= (1 << WGM12);             // Set CTC (Clear Timer on Compare Match) mode
  TCCR1B |= (1 << CS11) | (1 << CS10); // Set prescaler to 64
  
  OCR1A = 9999;                       // Set compare value for a 40 ms interrupt
  
  TIMSK1 |= (1 << OCIE1A);            // Enable interrupt on compare match A
  
  sei(); // Enable global interrupts
}

// Main setup function, runs once at the beginning
void setup() {
  configure_gpio();
  configure_timer_interrupts();
}

// Interrupt Service Routine (ISR) for Timer1 Compare Match A
ISR(TIMER1_COMPA_vect) {
  for (int i = 0; i < number_of_leds; i++) {
    led_array[i].countdown--;

    if (led_array[i].countdown == 0) {
      // Toggle the LED state using XOR
      PORTB ^= (1 << led_array[i].pin);
      // Reset the countdown timer
      led_array[i].countdown = led_array[i].reload_value;
    }
  }
}

// The main loop remains empty
void loop() {
  // All work is done asynchronously in the ISR, so the CPU is free for other tasks.
}
```

## 4. Верификация и результаты

### 4.1. Симуляция в Tinkercad

Корректность работы алгоритма и схемы была предварительно проверена в среде моделирования Tinkercad. Симуляция полностью отражает поведение реального устройства.

**[Ссылка на симуляцию в Tinkercad](https://www.tinkercad.com/things/367Ss2rE7Uo-ledcascadetimersregisters?sharecode=2219TxlFgr3UnwcwBgs86AMsTcRzvMm4yXWmnbEhAng)**

### 4.2. Демонстрация на физическом устройстве

Финальное подтверждение работоспособности было получено на физической плате Arduino UNO. Видеозапись демонстрирует асинхронное мигание пяти светодиодов в соответствии с заданными периодами.

<video width="320" height="240" controls>
  <source src="ard.mp4" type="video/mp4">
</video>

## 5. Заключение

Проект успешно демонстрирует реализацию неблокирующей многозадачной системы на микроконтроллере ATmega328P. Выбранная архитектура с использованием структур данных и индивидуальных счётчиков показала свою эффективность, модульность и масштабируемость.

Ключевые результаты:
- Создана детерминированная система с точными временными интервалами.
- Логика полностью асинхронна, основной цикл `loop()` свободен для других задач.
- Прямая работа с регистрами обеспечивает максимальное быстродействие.

Данный подход может быть легко адаптирован для управления более сложными системами, требующими одновременного выполнения нескольких периодических задач, такими как опрос датчиков, управление двигателями или обмен данными по протоколам.
