# Проект LedCascade: Асинхронное управление светодиодами на ATmega328P с использованием аппаратных прерываний

## 1. Введение

### 1.1. Контекст и цель проекта

Данный проект демонстрирует создание эффективной многозадачной системы управления периферией на примере пяти светодиодов, работающих с независимыми периодами мигания. Основная цель — реализовать неблокирующую логику управления, используя низкоуровневые возможности микроконтроллера ATmega328P: прямое манипулирование регистрами и аппаратные прерывания таймера. Такой подход является фундаментальным для разработки встраиваемых систем реального времени.

### 1.2. Обоснование выбранного подхода

Применение стандартных функций, таких как `delay()`, приводит к полной остановке (блокировке) микроконтроллера, что делает невозможным параллельное выполнение других задач. Использование высокоуровневых функций Arduino (`digitalWrite()`, `millis()`) вносит дополнительные накладные расходы и снижает детерминизм системы.

Выбранное решение основано на **аппаратных прерываниях от таймера**. Этот механизм позволяет выполнять основной код (`loop()`) и обработку событий асинхронно, обеспечивая максимальную отзывчивость и производительность системы. Управление выводами осуществляется напрямую через регистры `DDRB` и `PORTB` для минимизации задержек и полного контроля над аппаратной частью.

### 1.3. Архитектура решения

В основе архитектуры лежит модульный подход. Вместо глобального счётчика и ресурсоёмкой операции деления по модулю (`%`) для каждого светодиода создаётся отдельная управляющая структура (`LedController`). Эта структура инкапсулирует все необходимые параметры: номер пина, период мигания и индивидуальный счётчик обратного отсчёта.

Единый аппаратный таймер генерирует прерывания с фиксированным интервалом («тик»). Внутри обработчика прерывания (ISR) происходит итерация по массиву управляющих структур, декремент каждого счётчика и, при его обнулении, инверсия состояния соответствующего светодиода. Такая архитектура более масштабируема и эффективна.

## 2. Аппаратная конфигурация

### 2.1. Список компонентов

*   Плата Arduino UNO (на базе ATmega328P).
*   5 светодиодов.
*   5 токоограничивающих резисторов (номинал 220 Ом).
*   Макетная плата и соединительные провода.

### 2.2. Схема подключения

Светодиоды подключены к пинам порта `B` для удобства манипуляции через регистр `PORTB`.

| Компонент | Пин Arduino | Регистр и бит |
| :-------- | :---------: | :-----------: |
| Светодиод 1 |      8      |      PB0      |
| Светодиод 2 |      9      |      PB1      |
| Светодиод 3 |      10     |      PB2      |
| Светодиод 4 |      12     |      PB4      |
| Светодиод 5 |      13     |      PB5      |

## 3. Программная реализация

### 3.1. Структура данных (`LedController`)

Для организации управления была введена структура `LedController`, которая объединяет все параметры одного светодиода:

*   `pin`: номер бита в порте B, к которому подключен светодиод.
*   `reload_value`: константа, определяющая период мигания в "тиках" таймера.
*   `countdown`: переменная-счётчик, которая декрементируется при каждом тике таймера.

Такой подход позволяет легко добавлять новые светодиоды или изменять их параметры, не затрагивая основную логику.

### 3.2. Конфигурация Таймера1

Используется 16-битный **Таймер1** в режиме **CTC** (Clear Timer on Compare), что обеспечивает точную периодичность прерываний.

*   **Тактовая частота МК (F_CPU):** 16 МГц.
*   **Предделитель (Prescaler):** 64. Частота работы таймера: `16,000,000 Гц / 64 = 250,000` Гц.
*   **Требуемый интервал прерывания (базовый тик):** 40 мс (частота 25 Гц).
*   **Расчёт значения для `OCR1A`:**
    `OCR1A = (Частота таймера / Частота прерываний) - 1 = (250,000 / 25) - 1 = 9999`.

При достижении счётчиком `TCNT1` значения 9999 генерируется прерывание `TIMER1_COMPA_vect`, и счётчик автоматически сбрасывается в ноль.

### 3.3. Логика обработчика прерываний (ISR)

Обработчик прерывания `ISR(TIMER1_COMPA_vect)` выполняется каждые 40 мс и реализует всю логику управления:
1.  Осуществляется проход по массиву структур `led_array`.
2.  Для каждого светодиода декрементируется его личный счётчик `countdown`.
3.  Если счётчик достигает нуля, выполняется два действия:
    *   Состояние соответствующего пина инвертируется с помощью побитовой операции `XOR` (`PORTB ^= ...`).
    *   Счётчик `countdown` сбрасывается в своё начальное значение `reload_value`.

Этот метод не содержит сложных вычислений, что делает ISR максимально быстрым и эффективным.

### 3.4. Исходный код

Финальный код, реализующий описанную архитектуру.

```cpp
#include <avr/io.h>
#include <avr/interrupt.h>

// Определяем структуру для управления каждым светодиодом
struct LedController {
  const uint8_t pin;      // Пин, к которому подключен светодиод
  const int reload_value; // Значение, на которое сбрасывается счетчик (период)
  int countdown;          // Текущее значение обратного отсчета
};

// Создаем и инициализируем массив светодиодов
LedController led_array[] = {
  {PB0, 10, 10}, // Период 10 * 40 мс = 400 мс
  {PB1, 20, 20}, // Период 20 * 40 мс = 800 мс
  {PB2, 30, 30}, // Период 30 * 40 мс = 1200 мс
  {PB4, 40, 40}, // Период 40 * 40 мс = 1600 мс
  {PB5, 50, 50}  // Период 50 * 40 мс = 2000 мс
};

// Получаем количество светодиодов из размера массива
const int number_of_leds = sizeof(led_array) / sizeof(led_array);

// Вспомогательная функция для настройки пинов
void configure_gpio() {
  uint8_t pin_mask = 0;
  for (int i = 0; i < number_of_leds; i++) {
    pin_mask |= (1 << led_array[i].pin);
  }
  DDRB |= pin_mask;  // Все пины как выходы
  PORTB &= ~pin_mask; // Все светодиоды выключены
}

// Вспомогательная функция для настройки таймера
void configure_timer_interrupts() {
  cli();
  
  TCCR1A = 0;
  TCCR1B = 0;
  
  TCCR1B |= (1 << WGM12);             // Режим CTC
  TCCR1B |= (1 << CS11) | (1 << CS10); // Предделитель 64
  
  OCR1A = 9999;                       // Прерывание каждые 40 мс
  
  TIMSK1 |= (1 << OCIE1A);            // Разрешить прерывание по совпадению
  
  sei();
}

// Основная функция настройки
void setup() {
  configure_gpio();
  configure_timer_interrupts();
}

// Обработчик прерывания
ISR(TIMER1_COMPA_vect) {
  for (int i = 0; i < number_of_leds; i++) {
    led_array[i].countdown--;

    if (led_array[i].countdown == 0) {
      PORTB ^= (1 << led_array[i].pin);
      led_array[i].countdown = led_array[i].reload_value;
    }
  }
}

// Основной цикл остается пустым
void loop() {
  // Вся работа выполняется в прерываниях, процессор свободен
}
```

## 4. Верификация и результаты

### 4.1. Симуляция в Tinkercad

Корректность работы алгоритма и схемы была предварительно проверена в среде моделирования Tinkercad. Симуляция полностью отражает поведение реального устройства.

**[Ссылка на симуляцию в Tinkercad](https://www.tinkercad.com/things/367Ss2rE7Uo-ledcascadetimersregisters?sharecode=2219TxlFgr3UnwcwBgs86AMsTcRzvMm4yXWmnbEhAng)**

### 4.2. Демонстрация на физическом устройстве

Финальное подтверждение работоспособности было получено на физической плате Arduino UNO. Видеозапись демонстрирует асинхронное мигание пяти светодиодов в соответствии с заданными периодами.

<video width="320" height="240" controls>
  <source src="ard.mp4" type="video/mp4">
</video>

## 5. Заключение

Проект успешно демонстрирует реализацию неблокирующей многозадачной системы на микроконтроллере ATmega328P. Выбранная архитектура с использованием структур данных и индивидуальных счётчиков показала свою эффективность, модульность и масштабируемость.

Ключевые результаты:
- Создана детерминированная система с точными временными интервалами.
- Логика полностью асинхронна, основной цикл `loop()` свободен для других задач.
- Прямая работа с регистрами обеспечивает максимальное быстродействие.

Данный подход может быть легко адаптирован для управления более сложными системами, требующими одновременного выполнения нескольких периодических задач, такими как опрос датчиков, управление двигателями или обмен данными по протоколам.
