# Проект myUART: Асинхронная реализация UART на ATmega328P с использованием аппаратных прерываний

## 1. Введение

### 1.1. Контекст и цель проекта

Данный проект представляет собой полную программную реализацию асинхронного последовательного приемопередатчика (UART) для микроконтроллера ATmega328P. Основная цель — создать полнофункциональный, неблокирующий модуль для приёма (`RX`) и передачи (`TX`) данных, используя исключительно низкоуровневые возможности микроконтроллера: прямое манипулирование регистрами GPIO, аппаратный таймер и систему прерываний, без привлечения встроенного модуля USART.

### 1.2. Обоснование выбранного подхода

Стандартные подходы к последовательной связи в простых программах часто приводят к блокировке выполнения кода, что недопустимо в системах, где требуется одновременное выполнение нескольких задач. Выбранное решение основано на **аппаратных прерываниях от таймера и внешних событий**. Этот механизм позволяет выполнять основной код (`loop()`) и процессы приёма/передачи данных полностью асинхронно, обеспечивая максимальную отзывчивость и производительность системы. Управление выводами осуществляется напрямую через регистры `DDRD`, `PORTD` и `PIND` для минимизации задержек и полного контроля над аппаратной частью.

### 1.3. Архитектура решения

В основе архитектуры лежит полное разделение задач приёма и передачи с использованием одного аппаратного таймера (`Timer1`). Ключевая проблема — одновременная работа `TX` и `RX` — решается за счёт использования **двух независимых каналов сравнения таймера**: Канал `A` выделяется для `RX`, а канал `B` — для `TX`. Это позволяет генерировать отдельные прерывания для каждого процесса.

Для буферизации данных используются **кольцевые (циклические) буферы**, которые служат надёжным посредником между высокоуровневым пользовательским кодом и низкоуровневыми обработчиками прерываний, предотвращая потерю данных.

## 2. Аппаратная конфигурация

### 2.1. Список компонентов

*   Плата Arduino UNO (на базе ATmega328P) — 2 шт. для демонстрации двусторонней связи.
*   Соединительные провода.
*   Компьютер для мониторинга через аппаратный Serial порт.

### 2.2. Схема подключения

Для двусторонней связи между двумя платами используется перекрестное подключение.

| Назначение | Пин Arduino | Регистр и бит |
| :-------- | :---------: | :-----------: |
| **TX** (Передача) |      3      |      PD3      |
| **RX** (Приём)    |      2      |      PD2 (INT0) |

**Правила соединения:**
1. Пин `PD3` (TX) первой платы соединяется с пином `PD2` (RX) второй платы.
2. Пин `PD2` (RX) первой платы соединяется с пином `PD3` (TX) второй платы.
3. Выводы `GND` обеих плат должны быть соединены.

## 3. Программная реализация

### 3.1. Структуры данных (`RingBuffer`)

Для асинхронной буферизации данных для `TX` и `RX` используются два экземпляра структуры `RingBuffer` (кольцевой буфер). Она содержит:
*   `buffer`: массив для хранения данных.
*   `head`: `volatile` индекс для записи данных (управляется ISR для `RX` и основным кодом для `TX`).
*   `tail`: `volatile` индекс для чтения данных (управляется ISR для `TX` и основным кодом для `RX`).

Такой подход обеспечивает потокобезопасный обмен данными между основным кодом и обработчиками прерываний.

### 3.2. Конфигурация Таймера1 и внешнего прерывания

Используется 16-битный **Таймер1** и внешнее прерывание **INT0**.

*   **Тактовая частота МК (F_CPU):** 16 МГц.
*   **Предделитель (Prescaler):** 8. Частота работы таймера: `16,000,000 Гц / 8 = 2,000,000` Гц.
*   **Расчёт тиков на бит для 9600 бод:**
    `Ticks = (Частота таймера / Baud Rate) = (2,000,000 / 9600) ≈ 208`.
*   **Режим работы таймера:** Обычный режим. Прерывания генерируются по совпадению `TCNT1` со значениями в регистрах `OCR1A` (для RX) и `OCR1B` (для TX).
*   **Внешнее прерывание `INT0`:** Настроено на `FALLING` (спадающий фронт) для обнаружения стартового бита на пине `PD2`.

### 3.3. Логика обработчиков прерываний (ISR)

#### Процесс приёма (RX)
1.  **`ISR(INT0_vect)`**: Срабатывает по стартовому биту. Немедленно отключает себя, настраивает `OCR1A` на срабатывание через 1.5 битового интервала (для сэмплирования в середине первого бита данных) и включает прерывание `TIMER1_COMPA_vect`.
2.  **`ISR(TIMER1_COMPA_vect)`**: Срабатывает для каждого последующего бита. Считывает состояние пина `PD2`, сдвигает бит в байт-приёмник. После приёма 8 бит и проверки стоп-бита, готовый байт помещается в RX-буфер. Затем прерывание отключается, а `INT0` снова активируется.

#### Процесс передачи (TX)
1.  **`ISR(TIMER1_COMPB_vect)`**: Активируется, когда в TX-буфере появляются данные. В зависимости от текущего состояния (отправка старта, данных или стопа), выставляет нужный уровень на пине `PD3` и перенастраивает `OCR1B` на время следующего бита. Когда буфер пуст, прерывание отключается.

### 3.4. Исходный код

Финальный код, реализующий описанную архитектуру.

```cpp
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/atomic.h>

#define SERIAL_OUTPUT_PIN PD3
#define SERIAL_INPUT_PIN  PD2

#define OUTGOING_QUEUE_CAPACITY 64
#define INCOMING_QUEUE_CAPACITY 64

typedef struct {
    volatile uint8_t write_pos;
    volatile uint8_t read_pos;
    char data_array[INCOMING_QUEUE_CAPACITY];
} CircularQueue;

CircularQueue inbound_queue = {0, 0};
CircularQueue outbound_queue = {0, 0};

volatile uint16_t bit_duration_ticks;

enum TransmissionPhase { 
    PHASE_INACTIVE, PHASE_START, PHASE_PAYLOAD, PHASE_STOP 
};
volatile TransmissionPhase current_tx_phase = PHASE_INACTIVE;
volatile uint8_t outgoing_char;
volatile uint8_t tx_bit_counter;

enum ReceptionPhase { 
    PHASE_WAITING, PHASE_SAMPLING, PHASE_FINALIZE
};
volatile ReceptionPhase current_rx_phase = PHASE_WAITING;
volatile uint8_t incoming_char;
volatile uint8_t rx_bit_counter;

void soft_uart_initialize(uint16_t baud_rate) {
    uint32_t prescaler = 8;
    bit_duration_ticks = (F_CPU / prescaler) / baud_rate;

    DDRD |= (1 << SERIAL_OUTPUT_PIN);
    PORTD |= (1 << SERIAL_OUTPUT_PIN);
    DDRD &= ~(1 << SERIAL_INPUT_PIN);
    PORTD |= (1 << SERIAL_INPUT_PIN);

    TCCR1A = 0;
    TCCR1B = (1 << CS11);

    EICRA |= (1 << ISC01);
    EICRA &= ~(1 << ISC00);
    EIMSK |= (1 << INT0); 
    sei();
}

void soft_uart_transmit_byte(char character) {
    uint8_t next_write_pos = (outbound_queue.write_pos + 1) % OUTGOING_QUEUE_CAPACITY;
    while (next_write_pos == outbound_queue.read_pos);
    outbound_queue.data_array[outbound_queue.write_pos] = character;
    outbound_queue.write_pos = next_write_pos;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        if (current_tx_phase == PHASE_INACTIVE) {
            current_tx_phase = PHASE_START;
            OCR1B = TCNT1 + 10;
            TIMSK1 |= (1 << OCIE1B);
        }
    }
}

// ... (остальные функции API: print, available, receive)

ISR(INT0_vect) {
    EIMSK &= ~(1 << INT0);
    current_rx_phase = PHASE_SAMPLING;
    rx_bit_counter = 0;
    incoming_char = 0;
    OCR1A = TCNT1 + (bit_duration_ticks * 3 / 2);
    TIMSK1 |= (1 << OCIE1A);
}

ISR(TIMER1_COMPA_vect) {
    // ... (логика приёма)
}

ISR(TIMER1_COMPB_vect) {
    // ... (логика передачи)
}

void setup() {
    soft_uart_initialize(9600);
    soft_uart_print("Software UART Initialized.\n");
}

void loop() {
    if (soft_uart_data_waiting()) {
        char received_char = soft_uart_receive_byte();
        soft_uart_print("Echo: ");
        soft_uart_transmit_byte(received_char);
        soft_uart_print("\n");
    }
}
```

## 4. Верификация и результаты

### 4.1. Симуляция в Tinkercad

Корректность работы алгоритма и схемы была предварительно проверена в среде моделирования Tinkercad. Симуляция демонстрирует стабильный двусторонний обмен данными между двумя виртуальными платами.

**[Ссылка на симуляцию в Tinkercad]([https://www.tinkercad.com/things/f64J3D1R3p3-software-uart-demo](https://www.tinkercad.com/things/6QqapanaA1n-myuart?sharecode=BcQKNHFaL3I_8KSOyDPMcD3PaHby5LQK_hAZ_XzjUr4))**

### 4.2. Демонстрация на физическом устройстве

Финальное подтверждение работоспособности было получено на физической плате Arduino UNO. Видеозапись демонстрирует, как данные, отправленные с одной платы, принимаются другой и отправляются обратно (эхо), при этом основной цикл программы остается свободным.

<video width="320" height="240" controls>
  <source src="ard.mp4" type="video/mp4">
</video>

## 5. Заключение

Проект успешно демонстрирует реализацию надёжной, неблокирующей системы асинхронной последовательной связи на микроконтроллере ATmega328P. Выбранная архитектура с разделением каналов таймера и использованием кольцевых буферов показала свою эффективность и отказоустойчивость.

Ключевые результаты:
- Создана система, способная одновременно принимать и передавать данные.
- Логика полностью асинхронна, основной цикл `loop()` свободен для других задач.
- Прямая работа с регистрами обеспечивает максимальное быстродействие и точный контроль времени.

Данный подход является фундаментальным для построения сложных встраиваемых систем, требующих одновременного выполнения нескольких задач в режиме реального времени.````
